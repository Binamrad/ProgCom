;this file contains code designed to print text to the screen

.text
#include libExtnd.txt
#include libLabel.txt
#include libASCII.txt

#global setFontBackground
setBgCol:
	andi	r1, r1, 15;sanity check
	wr	r1, r0, colBackground
	ret

#global setFontCol
setFontCol:
	andi	r1, r1, 15;sanity check
	wr	r1, r0, colFont
	ret

;takes a char in r1 and puts it at the screen pointer
#global putChar
putChar:
	push	ra
	rd	r2, r0, screen_pointer
	
	;make sure screen pointer is in bounds
	movi	r3, screen_max
	bl	r2, r3, 5
	wr	r0, r0, screen_pointer
	push	r1
	call	scr_scroll
	pop	r1
	mov	r2, r0
	
	;add color to character
	rd	r3, r0, colFont
	sli	r3, r3, 8
	or	r1, r1, r3
	rd	r3, r0, colBackground
	sli	r3, r3, 12
	or	r1, r1, r3
	
	;get address
	andi	r3, r2, 1
	sri	r2, r2, 1

	;set character at proper position
	sli	r3, r3, 4
	shl	r1, r1, r3

	;read destination character
	rd	r4, r2, GLOBAL_SCREEN + 496

	;clear space for the character
	movi	r5, 0xffff
	shl	r5, r5, r3
	not	r5
	and	r4, r4, r5
	
	;merge character and write back
	or	r1, r1, r4
	wr	r1, r2, GLOBAL_SCREEN + 496

	;increment screen_pointer and write back
	rd	r1, r0, screen_pointer
	addi	r1, r1, 1
	wr	r1, r0, screen_pointer

	;return
	pop	ra
	ret

;the same as putChar, but takes formatting into account
#global printChar
printChar:
	push	ra
	
	;if tab, align to nearest four chars
	movi	r2, 9
	bne	r1, r2, printc_n
	rd	r3, r0, screen_pointer
	andi	r3, r3, 3
	movi	r4, 4
	sub	r3, r4, r3
printc_tab_loop:
	beq	r3, r0, printc_end
	push	r3
	movi	r1, 32
	call	putChar
	pop	r3
	subi	r3, r3, 1
	br	printc_tab_loop	

	;if newline, scroll screen upwards
printc_n:
	movi	r2, 10
	bne	r2, r1, printc_r
	call	scr_scroll
	br	printc_end

	;if carrige return, set screen_pointer to 0
printc_r:
	movi	r2, 13
	bne	r1, r2, printc_put
	wr	r0, r0, screen_pointer
	br	printc_end

	;else call putchar
printc_put:
	call	putChar

printc_end:	
	pop	ra
	ret

;prints the string r1 points to until it finds a null character
;this function has no regard for wrapping around the screen etc.
;this functions now uses string instead of #string_compact strings
#global printStr
printStr:
	push	a4
	push	ra
	mov	a4, r1

printsLoop:
	rd	r1, a4, 0
	beq	r1, r0, prints_end
	call	printChar
	addi	a4, a4, 1
	br	printsLoop

prints_end:
	pop	ra
	pop	a4

	ret

;same as above, except it prints a newline+carrige return after the text
#global printStrLn
printStrLn:
	push	ra

	call	printStr
	movi	r1, 10
	call	printChar
	movi	r1, 13
	call	printChar

	pop	ra
	ret

#global scr_scroll
scr_scroll:
	movi	r3, 512
	movi	r2, 0
movScrLoop:
	rd	r1, r2, GLOBAL_SCREEN + 16
	wr	r1, r2, GLOBAL_SCREEN + 0
	rd	r1, r2, GLOBAL_SCREEN + 17
	wr	r1, r2, GLOBAL_SCREEN + 1
	rd	r1, r2, GLOBAL_SCREEN + 18
	wr	r1, r2, GLOBAL_SCREEN + 2
	rd	r1, r2, GLOBAL_SCREEN + 19
	wr	r1, r2, GLOBAL_SCREEN + 3
	rd	r1, r2, GLOBAL_SCREEN + 20
	wr	r1, r2, GLOBAL_SCREEN + 4
	rd	r1, r2, GLOBAL_SCREEN + 21
	wr	r1, r2, GLOBAL_SCREEN + 5
	rd	r1, r2, GLOBAL_SCREEN + 22
	wr	r1, r2, GLOBAL_SCREEN + 6
	rd	r1, r2, GLOBAL_SCREEN + 23
	wr	r1, r2, GLOBAL_SCREEN + 7
	addi	r2, r2, 8
	bl	r2, r3, movScrLoop
	ret

#global moveCursorBack
moveCursorBack:
	rd	r1, r0, screen_pointer
	subi	r1, r1, 1
	bl	r1, r0, 2
	wr	r1, r0, screen_pointer
	ret
	wr	r0, r0, screen_pointer
	
	ret

;*************************************************************************************
;input code below


;get keyboard keypress, non-blocking
;does not unset the keyboard when reading
;return 1 in r2 if success, 0 if fail
;return keycode in r1
#global get_keypress
get_keypress:
	rd	r2, r0, GLOBAL_KEYBOARD_NEWIN
	rd	r1, r0, GLOBAL_KEYBOARD
	ret

;wait until a text-key has been pressed, then return it in r1
;guaranteed to be a ascii char
#global readChar
readChar:
	push	ra
	movi	r3, 255;r3 is not modified by rdkb
rdc_loop:
	call	get_keypress
	beq	r2, r0, rdc_loop
	wr	r0, r0, GLOBAL_KEYBOARD_NEWIN;make sure we don't read this char again
	bl	r1, r0, rdc_loop
	bl	r3, r1, rdc_loop
	pop	ra
	ret
	
;reads an enire string and stores it in the area pointed to by r1
;max length of string stored in r2
;enter is used to signify end of input
;the string is null terminated
;returns the pointer to the string in r1 unchanged
#global readString
readString:
	push	ra
	push	a4
	push	a5
	push	a6
	movi	a4, 0
	mov	a5, r1
	mov	a6, r2
	subi	a6, a6, 1;leave space for null termination
readStrLoop:
	;read characters until enter is pressed.
	;if backspace is pressed, remove one char from the stack
	call	readChar
	;make sure we did not press enter
	movi	r3, C_LF
	beq	r3, r1, readStrEnd
	
	;handle backspace
	movi	r3, C_BS
	bne	r3, r1, readStrChar
	beq	a4, r0, readStrLoop
	
	;remove last input char from string
	subi	a4, a4, 1
	;remove printed character from screen
	call	moveCursorBack
	movi	r1, 0
	call	putChar;remove last printed char
	call	moveCursorBack;make sure we are now printing to recently emptied space
	
	br	readStrLoop
readStrChar:
	beq	a4, a6, readStrLoop

	;print character
	push	r1
	call	printChar
	pop	r1
	
	;set character at current location in thing
	wrr	r1, a4, a5
	addi	a4, a4, 1

	;jump back to loop
	br	readStrLoop
readStrEnd:
	
	;insert null termination
	wrr	r0, a4, a5

	;print newline
	movi	r1, C_LF
	call	printChar
	movi	r1, C_CR
	call	printChar

	;return pointer
	mov	r1, a5

	pop	a6
	pop	a5
	pop	a4
	pop	ra
	ret

;*************************************************************

.data
screen_pointer:
	0
#define screen_max 32

colBackground:
	0
colFont:
	1